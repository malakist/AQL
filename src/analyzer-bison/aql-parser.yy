%skeleton "lalr1.cc"%require "2.4.1"%defines%define namespace "AQL"%define parser_class_name "aql_parser"%code requires{#include <string>#include "..\qtree\AqlNode.h"#include "..\qtree\StringNode.h"#include "..\qtree\FunctionNode.h"#include "..\qtree\ColumnNode.h"#include "..\qtree\MembersNode.h"#include "..\qtree\SelectNode.h"//#define YYSTYPE const char *namespace AQL {	class aql_driver; }}%parse-param { aql_driver& driver }%lex-param { aql_driver& driver }%locations%initial-action{	@$.begin.filename = @$.end.filename = &driver.file;};%debug%error-verbose%code {#include "aql-driver.h"}%token	END	0		"end"%token 	IDENTIFIER	"identifier"%token 	INTEGER 	"integer"%token	FLOAT 		"float"%token	STRING		"string"%token 	MEMBER_PTR	"->"%token 	EQ 			"=="%token	NE 			"!="%token	GT 			">"%token	LT 			"<"%token	GE 			">="%token	LE			"<="%token 	NOT 		"!"%token	AND 		"&&"%token	OR			"||"%token 	FROM_BEGIN 	"From"%token	WHERE_BEGIN "Where"%token	SELECT_BEGIN	"Select"%token 	Q_BEGIN 	"Begin Query"%token	Q_END		"End Query"%union{	AQL::AqlNode *aqlNode;	char * identifierName;}%type <aqlNode> expression%type <identifierName> IDENTIFIER%type <aqlNode> INTEGER FLOAT STRING%type <aqlNode> member_list%type <aqlNode> select_clause%%%start query;query: 				  "Begin Query" from_clause where_clause select_clause "End Query" 	{ }					| "Begin Query" from_clause select_clause "End Query"				{ }					;					from_clause:		  "From" table_list					;					table_list:			  table_identifier					| table_list ',' table_identifier					;table_identifier: 	  "identifier"					;					where_clause:		  "Where" predicate_list					;					predicate_list:		  predicate					| predicate_list "&&" predicate					| predicate_list "||" predicate					;					predicate:			  expression					| expression "==" expression		{   }					| expression "!=" expression					| expression ">" expression					| expression "<" expression					| expression ">=" expression					| expression "<=" expression					| "!" predicate					;select_clause:		  "Select"							{ $$ = new AQL::SelectNode(); }					| "Select" member_list										{ 							$$ = new AQL::SelectNode();							AQL::AqlNode * node = $2->getLeftNode();							while(node) {								$$->addChildNode(node);								node = node->getLeftNode();							}						}					;member_list:		  expression						{							$$ = new AQL::MembersNode(); $$->setRightNode($1); $$ = $1;						}					| member_list ',' expression						{							$1->setRightNode($3);							$$ = $3;						}					;				expression:			IDENTIFIER MEMBER_PTR IDENTIFIER								{							AQL::ColumnNode * node = new AQL::ColumnNode();							node->setTableName($1);							node->setColumnName($3);							$$ = node;						}					| IDENTIFIER '(' expression ')'									{							AQL::FunctionNode * node = new AQL::FunctionNode(); 							node->setFunctionName($1);							node->setArgument($3);							$$ = node; 						}					| '(' expression ')'                    { $$ = $2; }					| INTEGER					| FLOAT					| STRING					;					%%void AQL::aql_parser::error(const AQL::aql_parser::location_type& l, const std::string& m) {	driver.error(l, m);}